# Web Archive Browser Fix - Implementation Guide

**Version:** 2.0
**Date:** 2025-12-14
**Status:** IMPLEMENTED (OPT-121)

---

## Implementation Summary

All phases have been implemented:

| Phase | Status | Files Modified |
|-------|--------|----------------|
| Phase 1: Error Detection | ✅ Complete | `scripts/extract-text.py`, `websource-orchestrator-service.ts`, `websource-extraction-service.ts` |
| Phase 2: Extension-First | ✅ Complete | `websource-orchestrator-service.ts` |
| Phase 3: Session Data | ✅ Complete | `bookmark-api-server.ts` |
| Phase 4: WACZ Integration | ✅ Complete | NEW: `wacz-service.ts`, `websource-orchestrator-service.ts` |
| Phase 5: User Notifications | ✅ Complete | NEW: `CaptureProgress.svelte` |

---

## Architecture Understanding

### Current Design (Intentional)

```
Research Browser (Zero-Detection)
├── Launched via spawn(), NOT puppeteer
├── NO --remote-debugging-port (NO CDP)
├── NO automation artifacts
├── Communication via Extension + WebSocket
└── Indistinguishable from user browser

Archive Browser (Puppeteer)
├── Separate headless instance
├── Used for PDF/WARC generation
├── HAS CDP connection (detectable)
├── Cookie sync from Research Browser profile
└── Gets blocked by CloudFront/Cloudflare
```

### Why Research Browser is CDP-Free

From `detached-browser-service.ts` line 165-166:
```typescript
// CRITICAL: NO --remote-debugging-port flag (no CDP)
// CRITICAL: NO --enable-automation flag
```

This is **intentional** - adding CDP would defeat the purpose of zero-detection.

### The Real Solution

1. **Trust extension capture** - It runs IN the user's Research Browser
2. **Detect error pages** - Before storing 403 as content
3. **Smart routing** - Extension-first, Puppeteer only when needed
4. **Accept limitations** - PDF/WARC may fail on protected pages

---

## Phase 1: Error Detection

### 1.1 Python Script Changes (`scripts/extract-text.py`)

Add error page detection before extraction succeeds:

```python
# Error signatures to detect
ERROR_SIGNATURES = [
    # CloudFront (Amazon)
    ('cloudfront', 'generated by cloudfront'),
    ('cloudfront', 'request could not be satisfied'),
    ('cloudfront', 'cloudfront request id'),

    # Cloudflare
    ('cloudflare', 'checking your browser'),
    ('cloudflare', 'ray id:'),
    ('cloudflare', 'just a moment'),

    # Generic blocks
    ('access_denied', 'access denied'),
    ('access_denied', '403 error'),
    ('access_denied', 'forbidden'),

    # Bot detection
    ('bot_detection', 'verify you are human'),
    ('bot_detection', 'captcha'),
    ('bot_detection', 'unusual traffic'),
]
```

### 1.2 Orchestrator Changes (`websource-orchestrator-service.ts`)

Add CloudFront patterns to `detectBotBlock()`:

```typescript
// Add to indicators array
{ pattern: 'generated by cloudfront', reason: 'CloudFront 403 block' },
{ pattern: 'request could not be satisfied', reason: 'CloudFront request blocked' },
{ pattern: 'cloudfront request id', reason: 'CloudFront error page' },
```

### 1.3 Error Storage

Save error pages for debugging/ML:
```
_websources/[sourceId]/errors/
├── error.html      - Full HTML of error page
├── error.png       - Screenshot of error
└── error.json      - Detection metadata
```

---

## Phase 2: Extension-First Architecture

### 2.1 Current Extension Capture (`bookmark-api-server.ts`)

Extension already sends:
- `screenshot` - Base64 PNG
- `html` - Full DOM
- `textContent` - Extracted text
- `openGraph` - OG metadata
- `images` - Image metadata
- `links` - Link metadata

### 2.2 Skip Puppeteer When Extension Succeeded

In orchestrator, check if extension data is sufficient:

```typescript
// If extension captured high-quality data, skip Puppeteer re-fetch
if (source.extension_html_path && source.extension_screenshot_path) {
  // Use extension data for HTML/screenshot
  // Only use Puppeteer for PDF/WARC if needed
}
```

### 2.3 New Extension Data: Cookies + localStorage

Expand extension capture payload:

```javascript
// In extension content script
const captureData = {
  // Existing...
  screenshot: await captureScreenshot(),
  html: document.documentElement.outerHTML,
  textContent: extractText(),

  // NEW: Session data for authenticated re-fetch
  cookies: await browser.cookies.getAll({ url: window.location.href }),
  localStorage: JSON.stringify(Object.fromEntries(
    Object.entries(localStorage)
  )),
  sessionStorage: JSON.stringify(Object.fromEntries(
    Object.entries(sessionStorage)
  )),
};
```

---

## Phase 3: Capture Status Tracking

### 3.1 New Fields for Web Source

```sql
-- Add to web_sources table
capture_status TEXT DEFAULT 'pending',  -- pending, partial, complete, failed
capture_source TEXT,                     -- extension, puppeteer, both
extension_data_quality TEXT,             -- high, medium, low
puppeteer_blocked BOOLEAN DEFAULT 0,
block_reason TEXT,
```

### 3.2 Status Values

| Status | Meaning |
|--------|---------|
| `pending` | Not started |
| `partial` | Extension OK, Puppeteer blocked |
| `complete` | All formats captured |
| `failed` | Nothing captured |

### 3.3 User-Visible Status

```
┌─────────────────────────────────────────────────────────┐
│ Source: https://example.com/article                     │
│ Status: Partial Archive                                 │
│                                                         │
│ ✓ Screenshot (from your browser)                       │
│ ✓ HTML (from your browser)                             │
│ ✓ Text (extracted)                                     │
│ ✗ PDF (site blocked automated access)                  │
│ ✗ WARC (site blocked automated access)                 │
│                                                         │
│ This site blocks automated archiving. The content      │
│ captured from your browser session is preserved.       │
└─────────────────────────────────────────────────────────┘
```

---

## Phase 4: WACZ Integration

### 4.1 Add Dependency

```bash
cd packages/desktop
pnpm add @harvard-lil/js-wacz
```

### 4.2 WARC to WACZ Conversion

```typescript
// services/wacz-service.ts
import { WACZ } from '@harvard-lil/js-wacz';

export async function convertToWACZ(
  warcPath: string,
  outputPath: string,
  metadata?: { title?: string; url?: string }
): Promise<{ success: boolean; path?: string; error?: string }> {
  try {
    const archive = new WACZ({
      input: warcPath,
      output: outputPath,
      title: metadata?.title,
      url: metadata?.url,
    });

    await archive.process();

    return { success: true, path: outputPath };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
```

### 4.3 Auto-Convert After WARC Capture

In orchestrator, after successful WARC:

```typescript
if (warcPath) {
  const waczPath = warcPath.replace('.warc', '.wacz');
  const waczResult = await convertToWACZ(warcPath, waczPath, {
    title: source.title,
    url: source.url,
  });

  if (waczResult.success) {
    await repository.update(sourceId, { wacz_path: waczPath });
  }
}
```

---

## Phase 5: User Notifications

### 5.1 Capture Progress Component

```svelte
<!-- CaptureProgress.svelte -->
<script lang="ts">
  export let sourceId: string;
  export let status: CaptureStatus;
</script>

<div class="capture-progress">
  <div class="header">
    <span class="icon">{status.icon}</span>
    <span class="title">{status.title}</span>
  </div>

  <div class="checklist">
    {#each status.items as item}
      <div class="item" class:done={item.done} class:failed={item.failed}>
        <span class="check">{item.done ? '✓' : item.failed ? '✗' : '○'}</span>
        <span class="label">{item.label}</span>
        {#if item.note}
          <span class="note">{item.note}</span>
        {/if}
      </div>
    {/each}
  </div>

  {#if status.warning}
    <div class="warning">
      {status.warning}
    </div>
  {/if}
</div>
```

### 5.2 Browser Required Notification

For captures that need the Research Browser:

```svelte
<!-- BrowserRequiredNotice.svelte -->
<div class="notice">
  <h4>Research Browser Required</h4>
  <p>
    PDF and WARC generation requires the Research Browser to be open.
    These formats will be skipped if the browser is closed.
  </p>
  <button on:click={openBrowser}>Open Research Browser</button>
</div>
```

---

## Implementation Order

### Step 1: Error Detection (2-3 hours)
1. Update `scripts/extract-text.py` with error signatures
2. Update `websource-orchestrator-service.ts` with CloudFront patterns
3. Add error storage directory creation
4. Test with known 403 URL

### Step 2: Extension-First Logic (3-4 hours)
1. Update orchestrator to check extension capture quality
2. Skip Puppeteer re-fetch when extension data sufficient
3. Add capture_status field to database
4. Update UI to show partial captures

### Step 3: Enhanced Extension Data (2-3 hours)
1. Update extension to capture cookies/localStorage
2. Update `bookmark-api-server.ts` to receive session data
3. Store session data for potential re-use
4. Test with authenticated pages

### Step 4: WACZ Integration (2-3 hours)
1. Add js-wacz dependency
2. Create wacz-service.ts
3. Auto-convert WARCs to WACZ
4. Test archive playback

### Step 5: User Notifications (2-3 hours)
1. Create CaptureProgress component
2. Add status tracking to stores
3. Show appropriate notifications
4. Test user experience

---

## Testing Checklist

### Phase 1 Tests
- [ ] CloudFront 403 detected and flagged
- [ ] Cloudflare challenge detected
- [ ] Error page saved to errors/ directory
- [ ] Normal pages still capture correctly

### Phase 2 Tests
- [ ] Extension capture used when available
- [ ] Puppeteer skipped for protected pages
- [ ] Partial capture status shown correctly
- [ ] All formats on public pages

### Phase 3 Tests
- [ ] Cookies captured from extension
- [ ] localStorage captured from extension
- [ ] Session data stored correctly

### Phase 4 Tests
- [ ] WARC converts to WACZ
- [ ] WACZ file valid (can open in ReplayWeb.page)
- [ ] Conversion doesn't break on errors

### Phase 5 Tests
- [ ] Progress shown during capture
- [ ] Partial status clearly communicated
- [ ] No confusing error messages

---

## Files to Modify

| File | Changes |
|------|---------|
| `scripts/extract-text.py` | Add ERROR_SIGNATURES, detect_error_page() |
| `websource-orchestrator-service.ts` | Add CloudFront patterns, extension-first logic |
| `websource-extraction-service.ts` | Handle error page response from Python |
| `bookmark-api-server.ts` | Handle cookies/localStorage from extension |
| `sqlite-websources-repository.ts` | Add capture_status fields |
| NEW: `services/wacz-service.ts` | WARC to WACZ conversion |
| NEW: `components/CaptureProgress.svelte` | Progress UI |
| Extension `content.js` | Add cookies/localStorage capture |

---

## Audit Points

### CLAUDE.md Compliance
- [ ] No AI mention in UI
- [ ] Offline-first (WACZ works offline)
- [ ] Real-time UI updates (progress shown)
- [ ] Error handling with user-friendly messages
- [ ] Source attribution (error pages tracked)

### Security
- [ ] Cookies stored securely (not in plain JSON)
- [ ] localStorage not exposed to renderer
- [ ] No remote data transmission

### UX
- [ ] Clear status communication
- [ ] No confusing technical errors
- [ ] Graceful degradation
- [ ] Premium feel even on failures
