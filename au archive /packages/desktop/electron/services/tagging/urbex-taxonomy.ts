/**
 * Urbex Taxonomy - Domain-specific tag vocabulary for abandoned places
 *
 * Provides hierarchical categorization and normalization of tags
 * generated by RAM++ to match urban exploration terminology.
 *
 * Per CLAUDE.md Rule 9: Local LLMs for background tasks only.
 *
 * @module services/tagging/urbex-taxonomy
 */

// ============================================================================
// Type Definitions
// ============================================================================

export interface TagCategory {
  name: string;
  tags: string[];
  suggestsLocationType?: string;  // If majority of tags in this category, suggest this type
  suggestsEra?: string;           // If specific era-related tags detected
}

export interface NormalizedTag {
  original: string;
  normalized: string;
  category: string;
  subcategory?: string;
  confidence: number;
}

export interface ViewTypeResult {
  type: 'interior' | 'exterior' | 'aerial' | 'detail' | 'unknown';
  confidence: number;
}

export interface LocationTypeSuggestion {
  type: string;
  confidence: number;
  matchedTags: string[];
}

export interface EraSuggestion {
  era: string;
  confidence: number;
  matchedTags: string[];
}

// ============================================================================
// Urbex Taxonomy Definition
// ============================================================================

/**
 * Hierarchical taxonomy for abandoned places
 * Maps RAM++ generic tags to urbex-specific terminology
 */
export const URBEX_TAXONOMY: Record<string, TagCategory> = {
  // Building Types
  building_industrial: {
    name: 'Industrial',
    tags: [
      'factory', 'mill', 'warehouse', 'power plant', 'foundry', 'refinery',
      'manufacturing', 'industrial', 'plant', 'works', 'forge', 'smelter',
      'brewery', 'distillery', 'textile mill', 'steel mill', 'paper mill',
      'grain elevator', 'coal breaker', 'mine', 'quarry',
    ],
    suggestsLocationType: 'Industrial',
  },
  building_institutional: {
    name: 'Institutional',
    tags: [
      'hospital', 'asylum', 'sanatorium', 'prison', 'jail', 'penitentiary',
      'school', 'college', 'university', 'church', 'chapel', 'cathedral',
      'courthouse', 'government', 'library', 'museum', 'orphanage',
      'reformatory', 'institution', 'clinic', 'infirmary',
    ],
    suggestsLocationType: 'Institutional',
  },
  building_commercial: {
    name: 'Commercial',
    tags: [
      'hotel', 'motel', 'resort', 'theater', 'theatre', 'cinema', 'mall',
      'shopping', 'store', 'shop', 'office', 'bank', 'restaurant', 'bar',
      'nightclub', 'casino', 'arcade', 'bowling', 'amusement park',
      'theme park', 'zoo', 'aquarium',
    ],
    suggestsLocationType: 'Commercial',
  },
  building_residential: {
    name: 'Residential',
    tags: [
      'house', 'mansion', 'estate', 'farmhouse', 'cottage', 'cabin',
      'apartment', 'condo', 'villa', 'castle', 'palace', 'manor',
      'plantation', 'homestead', 'dwelling', 'residence',
    ],
    suggestsLocationType: 'Residential',
  },
  building_military: {
    name: 'Military',
    tags: [
      'military', 'army', 'navy', 'air force', 'base', 'fort', 'fortress',
      'bunker', 'barracks', 'armory', 'arsenal', 'missile', 'radar',
      'hangar', 'airfield', 'submarine', 'naval',
    ],
    suggestsLocationType: 'Military',
  },
  building_transportation: {
    name: 'Transportation',
    tags: [
      'train station', 'railway', 'railroad', 'depot', 'terminal', 'airport',
      'hangar', 'subway', 'metro', 'bus station', 'ferry', 'port', 'dock',
      'shipyard', 'roundhouse', 'locomotive', 'bridge', 'tunnel',
    ],
    suggestsLocationType: 'Transportation',
  },
  building_religious: {
    name: 'Religious',
    tags: [
      'church', 'chapel', 'cathedral', 'mosque', 'synagogue', 'temple',
      'monastery', 'convent', 'abbey', 'priory', 'seminary', 'shrine',
    ],
    suggestsLocationType: 'Religious',
  },
  building_recreational: {
    name: 'Recreational',
    tags: [
      'golf course', 'country club', 'pool', 'swimming', 'gymnasium', 'gym',
      'stadium', 'arena', 'ballpark', 'racetrack', 'speedway', 'ski resort',
      'campground', 'playground', 'park',
    ],
    suggestsLocationType: 'Recreational',
  },

  // Condition Tags
  condition_decay: {
    name: 'Decay',
    tags: [
      'decay', 'decayed', 'deterioration', 'deteriorated', 'weathered',
      'worn', 'aged', 'old', 'dilapidated', 'crumbling', 'rotting',
      'rusted', 'rust', 'corroded', 'corrosion', 'oxidized', 'patina',
      'peeling paint', 'flaking', 'faded', 'discolored',
    ],
  },
  condition_damage: {
    name: 'Damage',
    tags: [
      'broken', 'damaged', 'destroyed', 'collapsed', 'fallen', 'caved in',
      'fire damage', 'burned', 'charred', 'smoke damage', 'water damage',
      'flooded', 'moldy', 'mold', 'mildew', 'vandalized', 'smashed',
    ],
  },
  condition_nature: {
    name: 'Nature Reclaiming',
    tags: [
      'overgrown', 'vegetation', 'vines', 'ivy', 'moss', 'lichen',
      'trees', 'plants', 'weeds', 'grass', 'nature', 'reclaimed',
      'forest', 'jungle', 'wilderness', 'roots', 'ferns',
    ],
  },

  // Features
  feature_architectural: {
    name: 'Architectural Features',
    tags: [
      'columns', 'pillars', 'arches', 'archway', 'dome', 'cupola',
      'staircase', 'stairs', 'spiral staircase', 'balcony', 'terrace',
      'skylight', 'window', 'door', 'entrance', 'lobby', 'atrium',
      'hallway', 'corridor', 'ceiling', 'floor', 'wall', 'facade',
      'tower', 'spire', 'chimney', 'smokestack', 'roof', 'rooftop',
    ],
  },
  feature_equipment: {
    name: 'Equipment & Machinery',
    tags: [
      'machinery', 'machine', 'equipment', 'industrial equipment',
      'boiler', 'furnace', 'generator', 'turbine', 'engine', 'motor',
      'pipes', 'piping', 'ductwork', 'valves', 'gauges', 'meters',
      'control panel', 'switchboard', 'electrical', 'wiring',
      'conveyor', 'crane', 'hoist', 'pulley', 'winch', 'gear',
      'tank', 'vat', 'silo', 'hopper',
    ],
  },
  feature_furniture: {
    name: 'Furniture & Objects',
    tags: [
      'furniture', 'chair', 'table', 'desk', 'bed', 'sofa', 'couch',
      'cabinet', 'shelf', 'bookshelf', 'dresser', 'wardrobe', 'mirror',
      'lamp', 'chandelier', 'piano', 'organ', 'typewriter', 'telephone',
      'clock', 'safe', 'locker',
    ],
  },
  feature_vehicles: {
    name: 'Vehicles',
    tags: [
      'car', 'automobile', 'truck', 'bus', 'van', 'motorcycle',
      'train', 'locomotive', 'railcar', 'trolley', 'streetcar',
      'airplane', 'aircraft', 'helicopter', 'boat', 'ship',
      'ambulance', 'fire truck', 'police car', 'tractor', 'forklift',
    ],
  },

  // Art & Expression
  art_graffiti: {
    name: 'Graffiti & Street Art',
    tags: [
      'graffiti', 'street art', 'mural', 'tag', 'tagging', 'spray paint',
      'stencil', 'wheatpaste', 'poster', 'artwork', 'painting',
    ],
  },

  // View Types
  view_interior: {
    name: 'Interior Views',
    tags: [
      'interior', 'inside', 'indoor', 'room', 'hallway', 'corridor',
      'lobby', 'atrium', 'basement', 'attic', 'cellar',
    ],
  },
  view_exterior: {
    name: 'Exterior Views',
    tags: [
      'exterior', 'outside', 'outdoor', 'facade', 'front', 'entrance',
      'building', 'structure', 'architecture', 'skyline',
    ],
  },
  view_aerial: {
    name: 'Aerial Views',
    tags: [
      'aerial', 'drone', 'bird eye', 'overhead', 'rooftop', 'above',
      'sky', 'clouds', 'landscape',
    ],
  },

  // Lighting & Mood
  lighting: {
    name: 'Lighting',
    tags: [
      'light rays', 'sunlight', 'natural light', 'window light',
      'shadows', 'dark', 'darkness', 'flashlight', 'torch',
      'silhouette', 'backlit', 'golden hour', 'blue hour',
    ],
  },

  // Architectural Eras
  era_victorian: {
    name: 'Victorian Era',
    tags: [
      'victorian', 'ornate', 'decorative', 'elaborate', 'gothic',
      'neo-gothic', 'romanesque', 'queen anne', 'second empire',
    ],
    suggestsEra: '1870-1910',
  },
  era_industrial: {
    name: 'Industrial Era',
    tags: [
      'industrial revolution', 'brick', 'cast iron', 'wrought iron',
      'steam', 'coal', 'factory town',
    ],
    suggestsEra: '1850-1920',
  },
  era_artdeco: {
    name: 'Art Deco',
    tags: [
      'art deco', 'deco', 'streamline', 'geometric', 'zigzag',
      'sunburst', 'chevron', 'moderne',
    ],
    suggestsEra: '1920-1940',
  },
  era_midcentury: {
    name: 'Mid-Century Modern',
    tags: [
      'mid-century', 'modernist', 'international style', 'bauhaus',
      'minimalist', 'glass', 'steel', 'concrete', 'brutalist',
    ],
    suggestsEra: '1940-1970',
  },
  era_postmodern: {
    name: 'Late 20th Century',
    tags: [
      'postmodern', '1980s', '1990s', 'corporate', 'suburban',
    ],
    suggestsEra: '1970-2000',
  },
};

// ============================================================================
// Tag Normalization & Mapping
// ============================================================================

// Build reverse lookup: tag -> category
const TAG_TO_CATEGORY: Map<string, string> = new Map();
const TAG_TO_NORMALIZED: Map<string, string> = new Map();

// Synonyms for normalization
const TAG_SYNONYMS: Record<string, string> = {
  // Decay synonyms
  'rusted': 'rust',
  'corroded': 'corrosion',
  'deteriorated': 'decay',
  'deteriorating': 'decay',
  'decaying': 'decay',
  'weathering': 'weathered',
  'crumbled': 'crumbling',
  'rotted': 'rotting',
  'rotten': 'rotting',
  'oxidation': 'oxidized',

  // Building synonyms
  'theatre': 'theater',
  'gaol': 'jail',
  'penal': 'prison',
  'psychiatric': 'asylum',
  'mental hospital': 'asylum',
  'insane asylum': 'asylum',
  'lunatic asylum': 'asylum',
  'poorhouse': 'orphanage',
  'almshouse': 'orphanage',

  // Feature synonyms
  'stairs': 'staircase',
  'stairway': 'staircase',
  'steps': 'staircase',
  'window panes': 'window',
  'windows': 'window',
  'doorway': 'door',
  'columns': 'column',
  'pillars': 'column',

  // View synonyms
  'indoors': 'interior',
  'outdoors': 'exterior',
  'bird\'s eye': 'aerial',
  'birds eye': 'aerial',
};

// Initialize lookup maps
(function initializeMaps() {
  for (const [categoryKey, category] of Object.entries(URBEX_TAXONOMY)) {
    for (const tag of category.tags) {
      const normalizedTag = tag.toLowerCase();
      TAG_TO_CATEGORY.set(normalizedTag, categoryKey);
      TAG_TO_NORMALIZED.set(normalizedTag, normalizedTag);
    }
  }

  // Add synonyms
  for (const [synonym, normalized] of Object.entries(TAG_SYNONYMS)) {
    TAG_TO_NORMALIZED.set(synonym.toLowerCase(), normalized.toLowerCase());
    // Find which category the normalized tag belongs to
    const category = TAG_TO_CATEGORY.get(normalized.toLowerCase());
    if (category) {
      TAG_TO_CATEGORY.set(synonym.toLowerCase(), category);
    }
  }
})();

// ============================================================================
// Public Functions
// ============================================================================

/**
 * Normalize a single tag to urbex terminology
 */
export function normalizeTag(tag: string): NormalizedTag {
  const lowerTag = tag.toLowerCase().trim();

  // Check for exact match or synonym
  const normalized = TAG_TO_NORMALIZED.get(lowerTag) ?? lowerTag;
  const category = TAG_TO_CATEGORY.get(lowerTag) ?? TAG_TO_CATEGORY.get(normalized) ?? 'uncategorized';

  // Calculate confidence based on whether we found a match
  const confidence = TAG_TO_CATEGORY.has(lowerTag) ? 1.0 :
    TAG_TO_CATEGORY.has(normalized) ? 0.9 : 0.5;

  return {
    original: tag,
    normalized,
    category,
    confidence,
  };
}

/**
 * Normalize an array of tags, removing duplicates and sorting by relevance
 */
export function normalizeTags(tags: string[]): NormalizedTag[] {
  const seen = new Set<string>();
  const normalized: NormalizedTag[] = [];

  for (const tag of tags) {
    const result = normalizeTag(tag);
    if (!seen.has(result.normalized)) {
      seen.add(result.normalized);
      normalized.push(result);
    }
  }

  // Sort by confidence descending, then alphabetically
  return normalized.sort((a, b) => {
    if (b.confidence !== a.confidence) {
      return b.confidence - a.confidence;
    }
    return a.normalized.localeCompare(b.normalized);
  });
}

/**
 * Detect view type from tags
 */
export function detectViewType(tags: string[]): ViewTypeResult {
  const lowerTags = tags.map(t => t.toLowerCase());

  const interiorScore = URBEX_TAXONOMY.view_interior.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;
  const exteriorScore = URBEX_TAXONOMY.view_exterior.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;
  const aerialScore = URBEX_TAXONOMY.view_aerial.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;

  // Detail shots often have equipment/furniture but no view indicators
  const hasEquipment = URBEX_TAXONOMY.feature_equipment.tags
    .some(t => lowerTags.some(lt => lt.includes(t)));
  const hasFurniture = URBEX_TAXONOMY.feature_furniture.tags
    .some(t => lowerTags.some(lt => lt.includes(t)));

  const maxScore = Math.max(interiorScore, exteriorScore, aerialScore);

  if (maxScore === 0) {
    // If no view type detected but has objects, it's likely a detail shot
    if (hasEquipment || hasFurniture) {
      return { type: 'detail', confidence: 0.6 };
    }
    return { type: 'unknown', confidence: 0 };
  }

  if (aerialScore === maxScore && aerialScore > 0) {
    return { type: 'aerial', confidence: Math.min(aerialScore / 3, 1) };
  }
  if (exteriorScore > interiorScore) {
    return { type: 'exterior', confidence: Math.min(exteriorScore / 4, 1) };
  }
  if (interiorScore > 0) {
    return { type: 'interior', confidence: Math.min(interiorScore / 4, 1) };
  }

  return { type: 'unknown', confidence: 0 };
}

/**
 * Suggest location type based on tags
 */
export function suggestLocationType(tags: string[]): LocationTypeSuggestion | null {
  const lowerTags = tags.map(t => t.toLowerCase());
  const categoryCounts: Record<string, { count: number; tags: string[] }> = {};

  // Count matches per category
  for (const [categoryKey, category] of Object.entries(URBEX_TAXONOMY)) {
    if (!category.suggestsLocationType) continue;

    const matched = category.tags.filter(t =>
      lowerTags.some(lt => lt.includes(t) || t.includes(lt))
    );

    if (matched.length > 0) {
      const type = category.suggestsLocationType;
      if (!categoryCounts[type]) {
        categoryCounts[type] = { count: 0, tags: [] };
      }
      categoryCounts[type].count += matched.length;
      categoryCounts[type].tags.push(...matched);
    }
  }

  // Find best match
  let bestType: string | null = null;
  let bestCount = 0;
  let bestTags: string[] = [];

  for (const [type, data] of Object.entries(categoryCounts)) {
    if (data.count > bestCount) {
      bestCount = data.count;
      bestType = type;
      bestTags = data.tags;
    }
  }

  if (!bestType || bestCount < 2) {
    return null;
  }

  // Confidence based on number of matching tags
  const confidence = Math.min(bestCount / 5, 0.95);

  return {
    type: bestType,
    confidence,
    matchedTags: [...new Set(bestTags)],
  };
}

/**
 * Suggest era based on architectural style tags
 */
export function suggestEra(tags: string[]): EraSuggestion | null {
  const lowerTags = tags.map(t => t.toLowerCase());

  for (const [categoryKey, category] of Object.entries(URBEX_TAXONOMY)) {
    if (!category.suggestsEra) continue;

    const matched = category.tags.filter(t =>
      lowerTags.some(lt => lt.includes(t) || t.includes(lt))
    );

    if (matched.length >= 2) {
      return {
        era: category.suggestsEra,
        confidence: Math.min(matched.length / 3, 0.9),
        matchedTags: matched,
      };
    }
  }

  return null;
}

/**
 * Check if tags indicate specific conditions
 */
export function detectConditions(tags: string[]): {
  hasGraffiti: boolean;
  hasEquipment: boolean;
  hasDecay: boolean;
  hasNatureReclaim: boolean;
  conditionScore: number;
} {
  const lowerTags = tags.map(t => t.toLowerCase());

  const hasGraffiti = URBEX_TAXONOMY.art_graffiti.tags
    .some(t => lowerTags.some(lt => lt.includes(t)));

  const hasEquipment = URBEX_TAXONOMY.feature_equipment.tags
    .some(t => lowerTags.some(lt => lt.includes(t)));

  const decayCount = URBEX_TAXONOMY.condition_decay.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;
  const damageCount = URBEX_TAXONOMY.condition_damage.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;
  const natureCount = URBEX_TAXONOMY.condition_nature.tags
    .filter(t => lowerTags.some(lt => lt.includes(t))).length;

  const hasDecay = decayCount > 0 || damageCount > 0;
  const hasNatureReclaim = natureCount > 0;

  // Condition score: 0 = pristine, 1 = heavily decayed
  const totalDecayIndicators = decayCount + damageCount + natureCount;
  const conditionScore = Math.min(totalDecayIndicators / 8, 1);

  return {
    hasGraffiti,
    hasEquipment,
    hasDecay,
    hasNatureReclaim,
    conditionScore,
  };
}

/**
 * Get all category names for a list of tags
 */
export function getCategoriesForTags(tags: string[]): string[] {
  const categories = new Set<string>();

  for (const tag of tags) {
    const normalized = normalizeTag(tag);
    if (normalized.category !== 'uncategorized') {
      categories.add(normalized.category);
    }
  }

  return Array.from(categories);
}

/**
 * Filter tags to only include urbex-relevant ones
 */
export function filterRelevantTags(tags: string[], minConfidence = 0.5): string[] {
  return normalizeTags(tags)
    .filter(t => t.confidence >= minConfidence)
    .map(t => t.normalized);
}
